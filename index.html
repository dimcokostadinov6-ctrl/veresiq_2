<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Veresia</title>
<style>
  :root{--bg:#0e1116;--line:#1e3558;--ink:#f8fafc}
  html,body{margin:0;height:100%;background:#0b0f14;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;touch-action:none}
  .topbar{position:fixed;inset:0 0 auto 0;display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:rgba(11,15,20,.65);backdrop-filter:blur(8px);border-bottom:1px solid rgba(255,255,255,.06);z-index:5}
  .btn{appearance:none;border:1px solid rgba(255,255,255,.18);color:#e5e7eb;background:transparent;padding:.45rem .7rem;border-radius:.5rem;font-size:.95rem;cursor:pointer}
  .btn:hover{border-color:#ffffff44}
  .btn.primary{border-color:#60a5fa;background:#1e293b}
  .sep{flex:1}
  .stage{position:fixed;inset:44px 0 0 0;display:grid;grid-template-columns:1fr auto}
  .board-wrap{position:relative;overflow:hidden}
  canvas#board{
    width:100%;height:100%;display:block;touch-action:none;
    background:
      repeating-linear-gradient(to bottom,
        var(--bg) 0px, var(--bg) 26px,
        var(--line) 26px, var(--line) 27px);
  }
  .panel{width:min(360px,92vw);background:#0b1220;border-left:1px solid #1f2a44;padding:.75rem;display:none}
  .panel.open{display:block}
  .panel h3{margin:.2rem 0 .6rem;font-weight:600}
  .field{display:flex;gap:.5rem;align-items:center;margin:.25rem 0 .75rem}
  .field input{flex:1;padding:.45rem .6rem;border-radius:.45rem;background:#0c1426;color:#e5e7eb;border:1px solid #24314f}
  .pill{font-size:.8rem;padding:.2rem .45rem;border:1px solid #2b3b64;border-radius:999px}
  .list{font-size:.95rem;line-height:1.4}
  .list div{display:flex;justify-content:space-between;gap:.75rem;padding:.35rem .2rem;border-bottom:1px dashed #1c2744}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;background:#111827;border:1px solid #374151;padding:.6rem .8rem;border-radius:.6rem;z-index:10;display:none}
  .toast.show{display:block}
  #hint{font-size:.85rem;opacity:.9}
  .pen-indicator{position:fixed;left:6px;top:52px;width:34px;height:34px;border-radius:50%;background:#0e1628;border:1px solid #203255;display:grid;place-items:center;z-index:6}
  .pen-indicator:after{content:"✍️";font-size:18px}
</style>
</head>
<body>
  <div class="topbar">
    <strong>Veresia</strong>
    <button id="btnSave" class="btn primary">Запази</button>
    <div class="sep"></div>
    <button id="btnSearch" class="btn">Търсене</button>
    <span id="hint" title="Пише се само със стилус">✍️ Само писалка</span>
  </div>
  <div class="pen-indicator" title="Само със стилус"></div>

  <div class="stage">
    <div class="board-wrap">
      <canvas id="board"></canvas>
    </div>
    <aside id="searchPanel" class="panel" aria-label="Търсене">
      <h3>Търсене</h3>
      <div class="field">
        <input id="q" type="search" placeholder="Име…" list="suggestions"
               autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false"/>
        <datalist id="suggestions"></datalist>
        <span id="sum" class="pill">0.00 лв</span>
      </div>
      <div id="rows" class="list" aria-live="polite"></div>
    </aside>
  </div>

  <div id="toast" class="toast"></div>

<script>
/*** КОНФИГ ***/
let OCR_URL = "https://ocr-980985905017.europe-west1.run.app";
if (!/\/ocr\/?$/.test(OCR_URL)) OCR_URL = OCR_URL.replace(/\/?$/, "/ocr");

/*** IndexedDB — стабилен open (+ опция за пълно нулиране) ***/
const DB_NAME = 'veresia-db';
const STORE   = 'names';
const FORCE_DB_RESET = false; // сложи true за пълно чистене при всеки лоуд (бета)

function deleteDB(){
  return new Promise((res,rej)=>{
    const req = indexedDB.deleteDatabase(DB_NAME);
    req.onsuccess = ()=>res();
    req.onerror   = ()=>rej(req.error);
    req.onblocked = ()=>rej(new Error('deleteDatabase blocked'));
  });
}
function openDB(){
  return new Promise((resolve, reject)=>{
    const doOpen = ()=>{
      const req = indexedDB.open(DB_NAME);
      req.onupgradeneeded = ()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror   = async()=>{
        if (req.error && (req.error.name==='VersionError' || req.error.name==='InvalidStateError')) {
          try {
            await deleteDB();
            const again = indexedDB.open(DB_NAME);
            again.onupgradeneeded = ()=>{ const db=again.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE); };
            again.onsuccess = ()=> resolve(again.result);
            again.onerror   = ()=> reject(again.error);
          } catch(e){ reject(e); }
        } else reject(req.error);
      };
    };
    if (FORCE_DB_RESET) deleteDB().finally(doOpen); else doOpen();
  });
}
function withDB(mode, fn){
  return openDB().then(db => new Promise((res, rej)=>{
    const tx = db.transaction(STORE, mode);
    const s  = tx.objectStore(STORE);
    Promise.resolve(fn(s)).then(val=>{
      tx.oncomplete = ()=>{ db.close(); res(val); };
      tx.onerror    = ()=>{ db.close(); rej(tx.error); };
    }, err => { db.close(); rej(err); });
  }));
}
const idb = {
  get:(k)=>withDB('readonly',s=>new Promise((res,rej)=>{const r=s.get(k);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error)})),
  set:(k,v)=>withDB('readwrite',s=>new Promise((res,rej)=>{const r=s.put(v,k);r.onsuccess=()=>res();r.onerror=()=>rej(r.error)})),
  iterate:(cb)=>withDB('readonly',s=>new Promise((res,rej)=>{const r=s.openCursor();r.onsuccess=()=>{const c=r.result;if(c){cb(c.value,c.key);c.continue()}else res()};r.onerror=()=>rej(r.error)}))
};

/*** OCR Tuning + по-точен пре-процес и рязане по редове ***/
const OCR_TUNING = { scale: 5, splitLines: true, maxLines: 20 };

// Otsu + премахване на сини линии + инверсия + авто-кроп
function prepForOCR(src){
  const dpr = window.devicePixelRatio || 1;
  const scale = OCR_TUNING.scale;
  const w = Math.floor(src.width / dpr * scale);
  const h = Math.floor(src.height / dpr * scale);
  const out = document.createElement('canvas'); out.width=w; out.height=h;
  const ctx = out.getContext('2d', { willReadFrequently:true });
  ctx.drawImage(src, 0, 0, w, h);

  let img = ctx.getImageData(0,0,w,h), d = img.data;

  // Грейскейл + махни сините линии + инверсия (бялото мастило -> тъмно)
  for (let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    const isBlue = (b > r + 10) && (b > g + 8);
    if (isBlue){ d[i]=d[i+1]=d[i+2]=255; continue; }
    let lum = (0.299*r + 0.587*g + 0.114*b);
    lum = 255 - lum; d[i]=d[i+1]=d[i+2]=lum;
  }
  ctx.putImageData(img,0,0);

  // Otsu праг
  const hist = new Uint32Array(256);
  for (let i=0;i<d.length;i+=4) hist[d[i]]++;
  let sum=0; for(let i=0;i<256;i++) sum += i*hist[i];
  const tot = (d.length/4)|0;
  let sumB=0,wB=0,varMax=0,thr=127;
  for (let i=0;i<256;i++){
    wB += hist[i]; if(!wB) continue;
    const wF = tot - wB; if(!wF) break;
    sumB += i*hist[i];
    const mB = sumB / wB, mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF);
    if (between > varMax){ varMax=between; thr=i; }
  }
  for (let i=0;i<d.length;i+=4){
    const v = d[i] < thr ? 0 : 255;
    d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
  }
  ctx.putImageData(img,0,0);

  // --- Despeckle, но пази десетичната точка ---
  function hasNeighborInRange(arr,w,h,x,y,rx,ry){
    for(let yy=-ry; yy<=ry; yy++){
      for(let xx=-rx; xx<=rx; xx++){
        if(xx===0 && yy===0) continue;
        const X=x+xx, Y=y+yy;
        if(X<0||Y<0||X>=w||Y>=h) continue;
        if (arr[(Y*w+X)*4]===0) return true;
      }
    }
    return false;
  }
  for (let y=1;y<h-1;y++){
    for (let x=1;x<w-1;x++){
      const i=(y*w+x)*4;
      if (d[i]===0){
        // ако няма черни съседи в хоризонтал +/-2 и вертикал +/-1 → шум
        const nearInk = hasNeighborInRange(d,w,h,x,y,2,1);
        if (!nearInk){ d[i]=d[i+1]=d[i+2]=255; }
      }
    }
  }
  ctx.putImageData(img,0,0);

  // авто-кроп до мастилото
  let minX=w, minY=h, maxX=-1, maxY=-1;
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      if (d[(y*w+x)*4]===0){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
    }
  }
  if (maxX>=0){
    const pad=12;
    const x0=Math.max(0,minX-pad), y0=Math.max(0,minY-pad);
    const x1=Math.min(w-1,maxX+pad), y1=Math.min(h-1,maxY+pad);
    const cw=x1-x0+1, ch=y1-y0+1;
    const c=document.createElement('canvas'); c.width=cw; c.height=ch;
    c.getContext('2d').drawImage(out, x0, y0, cw, ch, 0, 0, cw, ch);
    return c;
  }
  return out;
}

// Рязане по хоризонтални сегменти (редове)
function sliceLines(binaryCanvas){
  const w=binaryCanvas.width, h=binaryCanvas.height;
  const ctx=binaryCanvas.getContext('2d');
  const img=ctx.getImageData(0,0,w,h), d=img.data;

  const rows = new Uint32Array(h);
  for (let y=0;y<h;y++){
    let cnt=0;
    for (let x=0;x<w;x++){ if (d[(y*w+x)*4]===0) cnt++; }
    rows[y]=cnt;
  }
  const thresh = Math.max(3, Math.floor(w*0.006));
  const ranges=[]; let inSeg=false, start=0;
  for (let y=0;y<h;y++){
    if (rows[y]>thresh){ if(!inSeg){inSeg=true; start=y;} }
    else if(inSeg){ ranges.push([start,y]); inSeg=false; }
  }
  if(inSeg) ranges.push([start,h]);

  const merged=[];
  for(const [s,e] of ranges){
    if(!merged.length) merged.push([s,e]);
    else{
      const last=merged[merged.length-1];
      if (s - last[1] <= 6) last[1]=e; else merged.push([s,e]);
    }
  }

  const canvases=[];
  for(const [sy,ey] of merged){
    const padY=6, y0=Math.max(0, sy-padY), y1=Math.min(h, ey+padY);
    let minX=w, maxX=-1;
    for(let x=0;x<w;x++){
      let black=0;
      for(let y=y0;y<y1;y++){ if (d[(y*w+x)*4]===0) black++; }
      if (black>0){ if(x<minX)minX=x; if(x>maxX)maxX=x; }
    }
    if (maxX>=0){
      const padX=10, x0=Math.max(0, minX-padX), x1=Math.min(w, maxX+padX);
      const cw=x1-x0, ch=y1-y0;
      const c=document.createElement('canvas'); c.width=cw; c.height=ch;
      c.getContext('2d').drawImage(binaryCanvas, x0, y0, cw, ch, 0, 0, cw, ch);
      canvases.push(c);
    }
  }
  return canvases;
}

async function callOCR(dataURL, signal){
  const r = await fetch(OCR_URL, {
    method:'POST',
    mode:'cors',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ imageBase64: dataURL.split(',')[1] }),
    signal
  });
  const j = await r.json();
  if(!r.ok || !j.ok) throw new Error(j?.error || ('HTTP '+r.status));
  return Array.isArray(j.entries) ? j.entries : [];
}

/*** Претеглен Damerau–Levenshtein за „щракване“ на имена ***/
function dlw(a,b){
  const al=a.toLowerCase(), bl=b.toLowerCase();
  const m=al.length,n=bl.length;
  const dp=Array.from({length:m+1},()=>new Array(n+1).fill(0));
  for(let i=0;i<=m;i++)dp[i][0]=i;
  for(let j=0;j<=n;j++)dp[0][j]=j;
  const near = new Set(['о-а','а-о','з-г','г-з','е-є','е-ё','и-й','у-ъ','к-х','л-и','д-л','с-о','в-у','п-р','м-н']);
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const ai=al[i-1], bj=bl[j-1];
      const sub = (ai===bj) ? 0 : (near.has(`${ai}-${bj}`) ? 0.4 : 1);
      let val = Math.min(
        dp[i-1][j] + 1,      // delete
        dp[i][j-1] + 1,      // insert
        dp[i-1][j-1] + sub   // substitute
      );
      // adjacent transposition
      if (i>1 && j>1 && al[i-1]===bl[j-2] && al[i-2]===bl[j-1]){
        val = Math.min(val, dp[i-2][j-2] + 0.4);
      }
      dp[i][j]=val;
    }
  }
  return dp[m][n];
}
async function normalizeName(raw){
  const pool=[]; await idb.iterate(v=>pool.push(v.name));
  if (!pool.length) return raw;
  let best=raw, bestD=1e9;
  for(const name of pool){
    const d=dlw(raw, name);
    if (d<bestD){ best=name; bestD=d; }
  }
  const L=Math.max(raw.length, best.length);
  const thr = L<=4 ? 1.2 : 2.4; // по-смел snap за кратки имена
  return (bestD<=thr) ? best : raw;
}

/*** UI / Canvas + логика ***/
window.addEventListener('DOMContentLoaded',()=>{
  const canvas=document.getElementById('board');
  const ctx=canvas.getContext('2d',{willReadFrequently:true});
  let drawing=false,last=null;

  function resize(){
    const dpr=window.devicePixelRatio||1;
    const r=canvas.getBoundingClientRect();
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.lineJoin='round';
    ctx.lineCap='round';
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--ink').trim()||'#fff';
  }
  window.addEventListener('resize',resize,{passive:true});
  window.addEventListener('orientationchange',()=>setTimeout(resize,50),{passive:true});
  resize();

  const isPen=e=>e.pointerType==='pen';
  const pos=e=>{const r=canvas.getBoundingClientRect();return {x:e.clientX-r.left,y:e.clientY-r.top,p:e.pressure||0.5}};
  canvas.addEventListener('pointerdown',e=>{if(!isPen(e))return;e.preventDefault();drawing=true;last=pos(e)});
  canvas.addEventListener('pointermove',e=>{if(!drawing||!isPen(e))return;const p=pos(e);ctx.lineWidth=2+p.p*3.5;ctx.beginPath();ctx.moveTo(last.x,last.y);ctx.lineTo(p.x,p.y);ctx.stroke();last=p;});
  const stop=()=>{drawing=false;last=null};canvas.addEventListener('pointerup',stop);canvas.addEventListener('pointercancel',stop);canvas.addEventListener('pointerleave',stop);

  const toastEl=document.getElementById('toast'); const hint=document.getElementById('hint');
  function toast(m,ms=2400){toastEl.textContent=m;toastEl.classList.add('show');clearTimeout(toastEl._t);toastEl._t=setTimeout(()=>toastEl.classList.remove('show'),ms)}
  const step=t=>{hint.textContent=t};

  async function saveEntry(name, amount, tsOverride){
    const key=name.trim().toLowerCase();
    const prev=await idb.get(key)||{name, total:0, items:[]};
    prev.total=+(prev.total+amount).toFixed(2);
    prev.items.push({amount, ts: tsOverride ?? Date.now()});
    await idb.set(key,prev);
  }
  async function allEntries(){
    const rows=[]; await idb.iterate(v=>rows.push(v));
    rows.sort((a,b)=>a.name.localeCompare(b.name,'bg')); return rows;
  }

  const panel=document.getElementById('searchPanel');const btnSearch=document.getElementById('btnSearch');
  const q=document.getElementById('q');const rowsEl=document.getElementById('rows');const sumEl=document.getElementById('sum');const sugg=document.getElementById('suggestions');

  btnSearch.onclick=async()=>{panel.classList.toggle('open');resize();if(panel.classList.contains('open')){await refreshSuggestions();renderSearch(q.value);q.focus()}};
  async function refreshSuggestions(){const rows=await allEntries();sugg.innerHTML='';rows.forEach(r=>{const o=document.createElement('option');o.value=r.name;sugg.appendChild(o)})}

  async function renderSearch(term){
    const t=(term||'').trim().toLowerCase();
    const rows=await allEntries();
    const items=[];
    rows.forEach(r=>{
      if(!t || r.name.toLowerCase().includes(t)){
        r.items.forEach(it=>items.push({name:r.name,amount:it.amount,ts:it.ts}));
      }
    });
    items.sort((a,b)=> a.ts - b.ts); // ред на писане
    let total=0; rowsEl.innerHTML='';
    items.forEach(x=>{
      total+=x.amount;
      const d=document.createElement('div');
      const when=new Date(x.ts).toLocaleString('bg-BG',{hour:'2-digit',minute:'2-digit',day:'2-digit',month:'2-digit'});
      d.innerHTML=`<span>${x.name}</span><span>${x.amount.toFixed(2)} лв</span><small>${when}</small>`;
      rowsEl.appendChild(d);
    });
    sumEl.textContent=`${total.toFixed(2)} лв`;
  }
  q.addEventListener('input',()=>renderSearch(q.value));

  async function sendToOCRFromCanvas(binaryCanvas){
    try{
      step('OCR: изпращане…');
      const ctl = new AbortController();
      const timeout = setTimeout(()=>ctl.abort(), 15000);

      let total=0;
      const baseTs = Date.now();

      if (OCR_TUNING.splitLines){
        const parts = sliceLines(binaryCanvas).slice(0, OCR_TUNING.maxLines);
        for (let i=0;i<parts.length;i++){
          const dataURL = parts[i].toDataURL('image/png');
          const entries = await callOCR(dataURL, ctl.signal);
          for (let j=0;j<entries.length;j++){
            const e = entries[j];
            const fixedName = await normalizeName(e.name);
            await saveEntry(fixedName, e.amount, baseTs + total + j);
          }
          total += entries.length;
        }
      } else {
        const dataURL = binaryCanvas.toDataURL('image/png');
        const entries = await callOCR(dataURL, ctl.signal);
        for (let i=0;i<entries.length;i++){
          const e = entries[i];
          const fixedName = await normalizeName(e.name);
          await saveEntry(fixedName, e.amount, baseTs + i);
        }
        total = entries.length;
      }

      clearTimeout(timeout);
      toast(total ? `Записани редове: ${total}` : 'Не открих „Име - сума“');
      if(panel.classList.contains('open')){ await refreshSuggestions(); renderSearch(q.value); }
      step('Готово');
    }catch(err){
      console.error('[OCR] →', err);
      toast(err.name==='AbortError' ? 'OCR таймаут' : 'OCR грешка (виж конзолата)');
      step('Грешка');
    }
  }

  const btnSave=document.getElementById('btnSave');
  btnSave.onclick=async()=>{
    try{
      step('Запис: снимка…');
      const blob=await new Promise(r=>canvas.toBlob(b=>r(b),'image/png'));
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
      a.download=`veresia-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
      document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(a.href);a.remove()},0);

      const bin=prepForOCR(canvas);
      const ctxBoard=canvas.getContext('2d'); ctxBoard.clearRect(0,0,canvas.width,canvas.height);

      void sendToOCRFromCanvas(bin);
    }catch(err){ console.error(err); toast('Грешка при „Запази“'); step('Грешка'); }
  };

  (async()=>{await refreshSuggestions()})();
});
</script>
</body>
</html>
