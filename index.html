<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Veresia – Hybrid OCR (Display & OCR layers)</title>
<style>
  :root{--bg:#0c1530;--line:#1d2b5c;--ink:#f8fafc;--panel:#0b1220;--text:#e5e7eb;--border:#24314f}
  html,body{margin:0;height:100%;background:#0b0f14;color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .topbar{position:fixed;inset:0 0 auto 0;display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:rgba(11,15,20,.65);backdrop-filter:blur(8px);border-bottom:1px solid rgba(255,255,255,.06);z-index:5}
  .btn{appearance:none;border:1px solid rgba(255,255,255,.18);color:var(--text);background:transparent;padding:.45rem .7rem;border-radius:.5rem;font-size:.95rem;cursor:pointer}
  .btn:hover{border-color:#ffffff44}
  .btn.primary{border-color:#60a5fa;background:#1e293b}
  .sep{flex:1}
  .stage{position:fixed;inset:44px 0 0 0;display:grid;grid-template-columns:1fr 360px}
  .board-wrap{position:relative;overflow:hidden}
  canvas#display{
    width:100%;height:100%;display:block;touch-action:none;
    background:
      repeating-linear-gradient(to bottom,
        var(--bg) 0px, var(--bg) 26px,
        var(--line) 26px, var(--line) 27px);
  }
  /* OCR канвасът е невидим */
  canvas#ocr{position:absolute;inset:0;opacity:0;pointer-events:none}

  aside.panel{background:var(--panel);border-left:1px solid #1f2a44;padding:.6rem .6rem 80px;overflow:auto}
  .h2{margin:.2rem 0 .4rem;font-weight:600}
  .row{display:flex;gap:.5rem;align-items:center;margin:.4rem 0}
  .pill{font-size:.8rem;padding:.2rem .45rem;border:1px solid #2b3b64;border-radius:999px}
  .hint{opacity:.8;font-size:.85rem}
  .queue{display:grid;gap:.5rem;margin-top:.5rem}
  .card{border:1px solid var(--border);border-radius:.6rem;overflow:hidden;background:#0b0f14}
  .card header{display:flex;align-items:center;gap:.5rem;padding:.4rem .5rem;border-bottom:1px solid #1c2744}
  .thumb{display:block;max-width:100%;background:#fff}
  .card .actions{display:flex;gap:.4rem;flex-wrap:wrap;padding:.4rem .5rem;border-top:1px dashed #1c2744}
  .chip{border:1px solid #2b3b64;border-radius:999px;padding:.25rem .5rem;cursor:pointer;background:#0c1426}
  .chip:hover{border-color:#4c68a8}
  .ok{background:#12321b;border-color:#1f7a3d}
  .danger{background:#321212;border-color:#7a1f1f}
  .name{font-weight:600}
  .small{font-size:.85rem;opacity:.9}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#111827;border:1px solid #374151;padding:.05rem .35rem;border-radius:.3rem;font-size:.8rem}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;background:#111827;border:1px solid #374151;padding:.6rem .8rem;border-radius:.6rem;z-index:10;display:none}
  .toast.show{display:block}
</style>
</head>
<body>
  <div class="topbar">
    <strong>Veresia</strong>
    <button id="btnSave" class="btn primary">Запази</button>
    <button id="btnPreview" class="btn">OCR преглед</button>
    <span class="sep"></span>
    <span class="hint">Пишеш <b>бяло на син фон</b> • OCR вижда <b>черно върху бяло</b></span>
  </div>

  <div class="stage">
    <div class="board-wrap">
      <canvas id="display"></canvas>
      <canvas id="ocr"></canvas>
    </div>

    <aside class="panel">
      <div class="h2">Опашка „За преглед“</div>
      <div class="hint">Бутоните <span class="kbd">1-5</span> избират предложение • <span class="kbd">Enter</span> приема</div>
      <div id="queue" class="queue"></div>
    </aside>
  </div>

  <div id="toast" class="toast"></div>

  <!-- Tesseract.js за локален OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
  /************* КОНФИГ *************/
  // Сложи тук твоя Cloud Run/Functions endpoint (с /ocr)
  let OCR_URL = "https://ocr-980985905017.europe-west1.run.app/ocr";
  const USE_CLOUD_FALLBACK = true;         // true = праща към Google при ниска увереност
  const CLIENT_CONF_THRESHOLD = 0.85;      // под това → fallback към облак
  const AUTO_ACCEPT_THRESHOLD = 0.92;      // общ скор (след фъзи) за авто-приемане

  // Сложи тук най-честите ви клиенти (за тест добавих няколко)
  const NAMES = [
    "Личо","Лена г","бр ники","стоилка",
    "кадето","мкр","снежа","вж","пиро",
    "осман","гича","вероника","венци",
    "вени","дедо г","кабаро"
  ];

  /************* ПОЛЕЗНИ *************/
  const toastEl = document.getElementById('toast');
  function toast(msg, ms=2000){ toastEl.textContent=msg; toastEl.classList.add('show'); clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.classList.remove('show'), ms); }
  function toDataURL(canvas){ return canvas.toDataURL('image/png'); }

  /************* СЛОЕВЕ: Display & OCR *************/
  const display = document.getElementById('display');
  const ocr = document.getElementById('ocr');
  const dCtx = display.getContext('2d', { willReadFrequently:true });
  const oCtx = ocr.getContext('2d', { willReadFrequently:true });

  function resizeCanvases(){
    const dpr = window.devicePixelRatio || 1;
    const r = display.getBoundingClientRect();
    [display, ocr].forEach(c=>{
      c.width = Math.floor(r.width*dpr);
      c.height = Math.floor(r.height*dpr);
      c.style.width = r.width+'px';
      c.style.height = r.height+'px';
    });
    dCtx.setTransform(dpr,0,0,dpr,0,0);
    oCtx.setTransform(dpr,0,0,dpr,0,0);
    // Display: рисуваме на син фон с бяла писалка
    dCtx.lineJoin='round'; dCtx.lineCap='round';
    dCtx.strokeStyle='#ffffff'; dCtx.lineWidth=3;
    // OCR: бял фон, черна писалка
    oCtx.lineJoin='round'; oCtx.lineCap='round';
    oCtx.strokeStyle='#000000'; oCtx.lineWidth=3;
    oCtx.fillStyle='#ffffff'; oCtx.fillRect(0,0,ocr.width,ocr.height);
  }
  window.addEventListener('resize', resizeCanvases, {passive:true});
  window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvases, 50), {passive:true});
  resizeCanvases();

  // Рисуване: бяло на син (display) + едновременно черно на бяло (ocr)
  let drawing=false, last=null;
  const pos = (e, el) => {
    const r = el.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top, p: e.pressure || 0.5 };
  };
  const isPen = e => e.pointerType==='pen' || e.pointerType==='touch' || e.pointerType==='mouse';

  display.addEventListener('pointerdown', e=>{
    if(!isPen(e)) return;
    e.preventDefault(); drawing=true; last=pos(e, display);
  });
  display.addEventListener('pointermove', e=>{
    if(!drawing) return;
    const p = pos(e, display);
    const w = 2 + p.p*3.5;
    dCtx.lineWidth=w; dCtx.beginPath(); dCtx.moveTo(last.x,last.y); dCtx.lineTo(p.x,p.y); dCtx.stroke();
    oCtx.lineWidth=w; oCtx.beginPath(); oCtx.moveTo(last.x,last.y); oCtx.lineTo(p.x,p.y); oCtx.stroke();
    last=p;
  });
  const stop=()=>{drawing=false; last=null};
  display.addEventListener('pointerup', stop);
  display.addEventListener('pointercancel', stop);
  display.addEventListener('pointerleave', stop);

  /************* OCR ПРЕГЛЕД *************/
  const btnPreview = document.getElementById('btnPreview');
  btnPreview.onclick = ()=>{
    const w = window.open('','_blank','width=900,height=700');
    w.document.write(`<img src="${toDataURL(ocr)}" style="max-width:100%"/>`);
    w.document.title = 'OCR Preview (черно на бяло)';
  };

  /************* СЕГМЕНТАЦИЯ НА БЛОКОВЕ *************/
  // Адаптивен анализ на редове: намира „мастилени“ хоризонтални зони и ги групира
  function segmentBlocks(canvas){
    const ctx = canvas.getContext('2d', { willReadFrequently:true });
    const {width:w, height:h} = canvas;
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;

    // 1) Вертикална проекция (по редове): колко „черно“ има на y
    const rowSum = new Float32Array(h);
    for(let y=0;y<h;y++){
      let s=0;
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        // пикселът е черен ако R,G,B са ниски → ползваме инверсия на яркостта
        const v = 255 - (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
        s += v;
      }
      rowSum[y]=s/(w*255); // нормализирано
    }

    // 2) Адаптивен праг: медиана + динамика
    const sorted = Array.from(rowSum).sort((a,b)=>a-b);
    const med = sorted[Math.floor(h*0.5)] || 0;
    const thr = Math.max(0.02, med*0.7); // пести шум, но хваща тънко писане

    // 3) Намираме „мастилени“ ленти (y1..y2)
    const bands=[];
    let inBand=false, y1=0;
    for(let y=0;y<h;y++){
      const ink = rowSum[y] > thr;
      if(ink && !inBand){ inBand=true; y1=y; }
      else if(!ink && inBand){ inBand=false; bands.push([y1,y-1]); }
    }
    if(inBand) bands.push([y1,h-1]);

    if(!bands.length) return [];

    // 4) Групиране на близки ленти в блокове (за 1–3 реда)
    const gaps = bands.map((b,i)=> i? (b[0]-bands[i-1][1]) : 0).slice(1);
    const medianGap = gaps.length ? gaps.sort((a,b)=>a-b)[Math.floor(gaps.length*0.5)] : 0;
    const maxJoinGap = Math.max(3, Math.floor(medianGap*1.2) || 12);

    const blocks = [];
    let cur = bands[0].slice();
    for(let i=1;i<bands.length;i++){
      const b = bands[i];
      if(b[0]-cur[1] <= maxJoinGap && (b[1]-cur[0]) <= 3*27*2){ // груба граница ≤ ~3 реда
        cur[1] = b[1];
      }else{
        blocks.push(cur); cur = b.slice();
      }
    }
    blocks.push(cur);

    // 5) Широчина по X за всеки блок (хоризонтална проекция в рамките на блока)
    const out=[];
    for(const [yy1,yy2] of blocks){
      let minX=w, maxX=0;
      for(let y=yy1;y<=yy2;y++){
        for(let x=0;x<w;x++){
          const i=(y*w+x)*4;
          const v = 255 - (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
          if(v>40){ // мастило
            if(x<minX) minX=x;
            if(x>maxX) maxX=x;
          }
        }
      }
      if(maxX-minX<10) continue; // твърде тънко
      // добавяме малък падинг
      const pad=8;
      out.push({x:Math.max(0,minX-pad), y:Math.max(0,yy1-pad), w:Math.min(w, (maxX-minX)+2*pad), h:Math.min(h, (yy2-yy1)+2*pad)});
    }
    return out;
  }

  /************* OCR (локално + fallback към облак) *************/
  async function ocrLocal(canvas){
    // Tesseract.js с български
    const worker = await Tesseract.createWorker('bul', 1, { logger: ()=>{} });
    const { data } = await worker.recognize(canvas);
    await worker.terminate();
    // Оценка на увереност (средно от думите, ако има)
    let conf = 0;
    if(data?.words?.length){
      conf = data.words.reduce((a,w)=>a+(w.confidence||0),0)/ (100*data.words.length);
    }else if(typeof data?.confidence==='number'){
      conf = (data.confidence||0)/100;
    }
    return { text: (data?.text||'').trim(), conf: Math.max(0, Math.min(1, conf||0)) };
  }

  async function ocrCloudFromDataURL(dataURL){
    const base64 = dataURL.split(',')[1];
    const r = await fetch(OCR_URL, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ imageBase64: base64 })
    });
    const j = await r.json();
    if(!r.ok || !j?.ok){
      throw new Error(j?.error || ('HTTP '+r.status));
    }
    return { text: (j.text||'').trim(), conf: 0.9, entries: j.entries||[] };
  }

  /************* ПАРСЕР „Име – сума“ *************/
  function parseEntries(text){
    const results = [];
    if(!text) return results;
    const norm = text
      .replace(/\u00A0/g,' ')
      .replace(/[–—−]/g,'-')
      .replace(/[,]/g, m=>','); // запетайката остава, по-късно я нормализираме

    // Стратегия:
    // 1) Ако има число на реда/в края на блока → търсим текст преди него за име.
    // 2) Приемаме (име)(разделител по избор)(сума), разделител може и да липсва.
    const lines = norm.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

    // Събираме в един буфер, защото често има пренос на ред
    const joined = lines.join(' ').replace(/\s+/g,' ');

    // Всички числа пари (1–4 цифри, по избор десетична част)
    const moneyRx = /([0-9]{1,4})(?:[.,]([0-9]{1,2}))?\s*(?:лв|лева)?/gi;
    let m, marks=[];
    while((m = moneyRx.exec(joined))!==null){
      const val = parseFloat(m[1] + '.' + (m[2]||'00'));
      marks.push({start:m.index, end: moneyRx.lastIndex, amount: +val.toFixed(2)});
    }
    if(!marks.length) return results;

    // За всеки маркер назад търсим име (кирилица, интервали, апостроф/тире/точка)
    for(const mk of marks){
      const left = joined.slice(0, mk.start).trim();
      // взимаме последните до 50 символа като кандидат за име
      let frag = left.slice(-50).replace(/[-=:]*\s*$/,'').trim();
      // чистим некирилица (оставяме интервали и базова пунктуация за имена)
      frag = frag.replace(/[^\p{Script=Cyrillic}\s.'’-]/gu,' ').replace(/\s+/g,' ').trim();
      if(!frag) continue;
      results.push({ name: frag, amount: mk.amount });
    }
    return results;
  }

  /************* ФЪЗИ-МАЧ (претеглен) *************/
  const CONF = new Map(Object.entries({
    "О:0":0.2,"0:О":0.2,"В:8":0.2,"8:В":0.2,"З:3":0.2,"3:З":0.2,"С:5":0.25,"5:С":0.25,
    "Т:7":0.25,"7:Т":0.25,"І:1":0.25,"1:І":0.25,"І:Л":0.3,"Л:І":0.3,"Н:И":0.35,"И:Н":0.35,
    "Й:И":0.2,"Ъ:У":0.45,"Ь:Ъ":0.45
  }));
  const normName = s => (s||'').toUpperCase().replace(/\s+/g,' ').replace(/[’']/g,'’').trim();
  function wCost(a,b){
    if(a===b) return 0;
    if(!a || !b) return 1; // инс/дел
    const k = `${a}:${b}`; return CONF.get(k) ?? 1;
  }
  function wLev(a,b){
    a = normName(a); b = normName(b);
    const n=a.length, m=b.length;
    if(n===0 && m===0) return 0;
    const dp = Array.from({length:n+1},()=>Array(m+1).fill(0));
    for(let i=1;i<=n;i++) dp[i][0]=dp[i-1][0]+wCost(a[i-1],'');
    for(let j=1;j<=m;j++) dp[0][j]=dp[0][j-1]+wCost('',b[j-1]);
    for(let i=1;i<=n;i++) for(let j=1;j<=m;j++){
      const sub=dp[i-1][j-1]+wCost(a[i-1],b[j-1]);
      const del=dp[i-1][j]+wCost(a[i-1],'');
      const ins=dp[i][j-1]+wCost('',b[j-1]);
      dp[i][j]=Math.min(sub,del,ins);
    }
    const maxLen = Math.max(n,m)||1;
    return dp[n][m]/maxLen; // по-ниско е по-добре
  }
  function bestCandidates(hint, k=5){
    const scored = NAMES.map(n=>({name:n, score:wLev(hint, n)})).sort((a,b)=>a.score-b.score);
    return scored.slice(0,k);
  }

  /************* ОПАШКА ЗА ПРЕГЛЕД *************/
  const queueEl = document.getElementById('queue');
  function queueCard({imgSrc, rawText, entries, candidates}){
    const div = document.createElement('div'); div.className='card';
    const head = document.createElement('header');
    head.innerHTML = `<div class="small">OCR: <span>${(rawText||'').slice(0,80).replace(/</g,'&lt;')}...</span></div>`;
    const thumb = document.createElement('img'); thumb.className='thumb'; thumb.src = imgSrc;
    const acts = document.createElement('div'); acts.className='actions';

    // Ако имаме парснати записи – показваме първия и предложения
    let chosen = null;
    const first = entries && entries[0] ? entries[0] : null;

    const nameSpan = document.createElement('span'); nameSpan.className='name';
    nameSpan.textContent = first ? first.name : '—';
    const amtSpan = document.createElement('span'); amtSpan.className='pill';
    amtSpan.textContent = first ? `${first.amount.toFixed(2)} лв` : '—';
    head.prepend(amtSpan); head.prepend(nameSpan);

    // Предложения 1..5
    (candidates||[]).forEach((c,i)=>{
      const chip = document.createElement('button');
      chip.className='chip';
      chip.textContent = `${i+1}. ${c.name}`;
      chip.onclick = ()=>{ nameSpan.textContent=c.name; chosen={name:c.name, amount:first?first.amount:0}; };
      acts.appendChild(chip);
    });

    // Приеми
    const accept = document.createElement('button');
    accept.className='chip ok'; accept.textContent='Приеми';
    accept.onclick = ()=>{
      if(!first && !chosen){ toast('Няма валиден запис'); return; }
      const final = { name: chosen?.name || first.name, amount: (first?first.amount:0) };
      // TODO: тук го запиши в твоя IndexedDB/бекенд – оставяме място
      div.remove(); toast(`Записано: ${final.name} – ${final.amount.toFixed(2)} лв`);
    };
    acts.appendChild(accept);

    // Пропусни
    const skip = document.createElement('button');
    skip.className='chip danger'; skip.textContent='Пропусни';
    skip.onclick = ()=>div.remove();
    acts.appendChild(skip);

    div.appendChild(head);
    div.appendChild(thumb);
    div.appendChild(acts);
    queueEl.appendChild(div);
  }

  /************* ОСНОВЕН ПОТОК „Запази“ *************/
  const btnSave = document.getElementById('btnSave');
  btnSave.onclick = async ()=>{
    try{
      // 1) Сегментираме блокове върху OCR канваса (черно-на-бяло)
      const blocks = segmentBlocks(ocr);
      if(!blocks.length){ toast('Няма мастило за OCR'); return; }

      // 2) За всеки блок → OCR локално; ако conf < праг и е активиран fallback → облак
      for(const b of blocks){
        // изрязване
        const tmp = document.createElement('canvas');
        tmp.width=b.w; tmp.height=b.h;
        const tctx = tmp.getContext('2d'); tctx.fillStyle='#fff'; tctx.fillRect(0,0,b.w,b.h);
        tctx.drawImage(ocr, b.x, b.y, b.w, b.h, 0, 0, b.w, b.h);

        // локален OCR
        const local = await ocrLocal(tmp);
        let text = local.text, conf = local.conf, cloudEntries=null;

        if(USE_CLOUD_FALLBACK && conf < CLIENT_CONF_THRESHOLD && OCR_URL){
          try{
            const cloud = await ocrCloudFromDataURL(tmp.toDataURL('image/png'));
            // избираме по-доброто (или комбинираме)
            if((cloud.text||'').length > (text||'').length) { text = cloud.text; conf = cloud.conf; }
            cloudEntries = cloud.entries;
          }catch(e){ /* ако облакът счупи – игнорирай */ }
        }

        // 3) Парсваме „име – сума“
        let entries = cloudEntries && cloudEntries.length ? cloudEntries : parseEntries(text);

        // 4) Ако имаме име – фъзи предложения
        let candidates=[];
        if(entries && entries[0] && entries[0].name){
          candidates = bestCandidates(entries[0].name, 5);
        }

        // 5) Авто-приемане ако скорът е висок (прибл. от фъзи)
        let auto=false;
        if(candidates[0]){
          const fuzzyScore = 1 - candidates[0].score; // 0..1 (по-високо е по-добре)
          const finalScore = 0.7*(conf||0) + 0.3*(fuzzyScore||0);
          if(finalScore >= AUTO_ACCEPT_THRESHOLD && entries[0]){
            // Тук можеш директно да записваш в твоята БД
            // (за демо – пращаме в опашката като „прието“)
            queueCard({
              imgSrc: tmp.toDataURL('image/png'),
              rawText: text,
              entries: entries,
              candidates: [candidates[0]] // показваме победителя само информативно
            });
            auto=true;
          }
        }

        if(!auto){
          // Показваме за преглед с топ-5
          queueCard({
            imgSrc: tmp.toDataURL('image/png'),
            rawText: text,
            entries: entries,
            candidates: candidates
          });
        }
      }

      toast('Готово: блоковете са в опашката за преглед');
      // 6) Изчистваме страницата за нов лист (по твое желание)
      dCtx.clearRect(0,0,display.width,display.height);
      oCtx.fillStyle='#ffffff'; oCtx.fillRect(0,0,ocr.width,ocr.height);

    }catch(err){
      console.error(err);
      toast('Грешка при „Запази“ (виж конзолата)');
    }
  };
  </script>
</body>
</html>
