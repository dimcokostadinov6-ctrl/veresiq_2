<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Veresia</title>
<style>
  :root{
    --bg:#0e1620; --line:#16345a; --ink:#f8fafc; --ui:#111827; --ui2:#1f2937; --accent:#22c55e;
    --muted:#9ca3af;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .bar{position:fixed;inset:0 0 auto 0;display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:linear-gradient(#0b1220cc,#0b1220cc);backdrop-filter:saturate(1.2) blur(6px);z-index:20}
  .bar h1{margin:0;font-size:1rem;opacity:.9}
  .btn{appearance:none;border:1px solid #374151;background:var(--ui2);color:#e5e7eb;border-radius:.5rem;padding:.5rem .8rem;font-weight:600;cursor:pointer}
  .btn:hover{background:#2b3647}
  .btn.primary{border-color:#16a34a;background:#16a34a;color:#07130a}
  .status{margin-left:auto;font-size:.9rem;color:var(--muted)}
  .wrap{position:fixed;inset:44px 0 0 0;display:grid}
  /* ruled paper */
  canvas{background:
      repeating-linear-gradient( to bottom,
        transparent 0 34px, var(--line) 34px 35px),
      linear-gradient(var(--bg),var(--bg));
    touch-action:none; /* изключва скрол по време на писалка */
  }
  /* Search panel */
  .panel{
    position:fixed;top:52px;right:.75rem;width:min(420px,calc(100vw - 1.5rem));
    background:var(--ui);border:1px solid #334155;border-radius:.75rem;box-shadow:0 10px 30px #0006;
    padding:.9rem;display:none;z-index:30
  }
  .panel.open{display:block}
  .row{display:flex;gap:.5rem;align-items:center;margin:.5rem 0}
  input[type="text"]{flex:1;appearance:none;background:#0b1220;border:1px solid #334155;border-radius:.5rem;color:#e5e7eb;padding:.55rem .7rem}
  .muted{color:var(--muted);font-size:.9rem}
  .pill{display:inline-block;border:1px solid #334155;border-radius:999px;padding:.15rem .5rem;margin-left:.5rem}
</style>
</head>
<body>
  <div class="bar">
    <h1>Veresia</h1>
    <button id="saveBtn" class="btn primary">Запази</button>
    <button id="searchBtn" class="btn">Търсене</button>
    <div class="status" id="status">OCR: готов</div>
  </div>

  <div class="wrap">
    <canvas id="pad"></canvas>
  </div>

  <div id="searchPanel" class="panel" role="dialog" aria-modal="true">
    <div class="row">
      <input id="q" list="namesList" placeholder="Име…">
      <datalist id="namesList"></datalist>
      <button id="doSearch" class="btn">Търси</button>
    </div>
    <div id="result" class="muted">Няма резултат.</div>
  </div>

<script>
/* ========= DPI & Canvas ========= */
const canvas = document.getElementById('pad');
const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:true });
let dpi = window.devicePixelRatio || 1;
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width  = Math.round(rect.width  * dpi);
  canvas.height = Math.round((window.innerHeight - 44) * dpi);
  canvas.style.width  = '100%';
  canvas.style.height = (window.innerHeight - 44) + 'px';
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--ink').trim();
  ctx.lineWidth=6 * dpi;
  redrawBg();
}
function redrawBg(){
  // фонът е в CSS; нищо специално тук
}

/* ========= Ink engine (only stylus) ========= */
let drawing=false, pts=[], lastRect=null;
canvas.addEventListener('pointerdown', e=>{
  if(e.pointerType!=='pen') return; // само химикал
  e.preventDefault(); canvas.setPointerCapture(e.pointerId);
  drawing=true; pts=[[e.clientX,e.clientY,e.pressure,performance.now()]];
  lastRect = canvas.getBoundingClientRect();
  strokeTo(e);
});
canvas.addEventListener('pointermove', e=>{
  if(!drawing || e.pointerType!=='pen') return;
  strokeTo(e);
});
canvas.addEventListener('pointerup', e=>{
  if(!drawing) return;
  drawing=false; canvas.releasePointerCapture(e.pointerId);
  // проста детекция за права линия (hook за „зачертаване“)
  maybeStrikeDelete(pts);
});
function strokeTo(e){
  // корекция на офсета (без 2см изоставане)
  const x = (e.clientX - lastRect.left) * dpi;
  const y = (e.clientY - lastRect.top ) * dpi;
  const p = Math.max(0.15, e.pressure||0.7);
  const last = pts[pts.length-1];
  pts.push([x,y,p,performance.now()]);
  if(last){
    ctx.lineWidth = 6 * dpi * p;
    ctx.beginPath(); ctx.moveTo(last[0], last[1]); ctx.lineTo(x,y); ctx.stroke();
  }
}

/* ========= Simple IndexedDB (без външни библиотеки) ========= */
const DB = (()=>{
  const DB_NAME='veresia_db', STORE='names';
  let dbp=null;
  function open(){
    if(dbp) return dbp;
    dbp = new Promise((res,rej)=>{
      const req=indexedDB.open(DB_NAME,1);
      req.onupgradeneeded=()=> req.result.createObjectStore(STORE);
      req.onsuccess = ()=>res(req.result);
      req.onerror = ()=>rej(req.error);
    });
    return dbp;
  }
  async function get(key){
    const db=await open();
    return new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readonly').objectStore(STORE).get(key.toLowerCase());
      tx.onsuccess=()=>res(tx.result); tx.onerror=()=>rej(tx.error);
    });
  }
  async function set(key,val){
    const db=await open();
    return new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readwrite').objectStore(STORE).put(val,key.toLowerCase());
      tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);
    });
  }
  async function del(key){
    const db=await open();
    return new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readwrite').objectStore(STORE).delete(key.toLowerCase());
      tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);
    });
  }
  async function keys(){
    const db=await open(); const out=[];
    return new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readonly').objectStore(STORE).openKeyCursor();
      tx.onsuccess=e=>{
        const c=e.target.result; if(c){ out.push(c.key); c.continue(); } else res(out);
      };
      tx.onerror=()=>rej(tx.error);
    });
  }
  return {get,set,del,keys};
})();

/* ========= Tesseract worker (one-time) ========= */
let worker=null, workerReady=false, ocrLoading=false;
const statusEl=document.getElementById('status');
async function ensureWorker(){
  if(workerReady || ocrLoading) return;
  ocrLoading=true; setStatus('OCR: зареждане…');
  const T = await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js', 'Tesseract');
  worker = await T.createWorker({
    logger:m=>{ if(m?.status==='loading tesseract core') setStatus('OCR: ядро…');
                if(m?.status==='initializing tesseract') setStatus('OCR: инициализация…');
                if(m?.status==='loading language traineddata') setStatus(`OCR: език… ${Math.round((m.progress||0)*100)}%`); },
    workerPath:'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js',
    corePath  :'https://cdn.jsdelivr.net/npm/tesseract.js-core@5/dist/tesseract-core.wasm.js',
    langPath  :'https://tessdata.projectnaptha.com/4.0.0_fast'
  });
  await worker.load();
  await worker.loadLanguage('bul+eng');
  await worker.initialize('bul+eng');
  workerReady=true; ocrLoading=false; setStatus('OCR: готов');
}
function setStatus(t){ statusEl.textContent=t; }
function loadScript(src, globalName){
  return new Promise((res,rej)=>{
    if(globalName && window[globalName]) return res(window[globalName]);
    const s=document.createElement('script'); s.src=src; s.async=true;
    s.onload=()=>res(window[globalName]); s.onerror=()=>rej(new Error('load '+src));
    document.head.appendChild(s);
  });
}

/* ========= Save flow ========= */
async function saveAll(){
  // 1) snapshot → blob
  const png = await canvasToBlob(canvas);
  // 2) OCR (с таймаут и graceful fallback)
  let found=[];
  try{
    await ensureWorker();
    setStatus('OCR: разпознаване…');
    const text = await recognizeWithTimeout(png, 15000);
    found = parseLines(text);
    // запиши/натрупай в DB
    for(const {name,amount} of found){
      const prev = await DB.get(name) || 0;
      await DB.set(name, +(prev + amount).toFixed(2));
    }
    setStatus(`OCR: готов • извлечени: ${found.length}`);
  }catch(err){
    console.warn(err);
    setStatus('OCR: пропуснато (няма модел/таймаут)');
  }
  // 3) свали PNG локално (може да го изключиш)
  downloadBlob(png, `veresia-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`);
  // 4) Почисти платното сигурно
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.restore();
  redrawBg();
  // 5) опресни списъка за autocomplete
  populateNamesList();
}
function canvasToBlob(cnv){
  return new Promise(res=> cnv.toBlob(b=>res(b),'image/png', 0.92));
}
async function recognizeWithTimeout(blob, ms){
  const p = (async()=>{
    const { data:{ text } } = await worker.recognize(blob, { tessedit_pageseg_mode:6 });
    return text;
  })();
  const t = new Promise((_,rej)=> setTimeout(()=>rej(new Error('ocr timeout')), ms));
  return Promise.race([p,t]);
}
function parseLines(txt){
  const out=[]; if(!txt) return out;
  // примерни редове: "Иван - 32,80", "Петър: 12.5", "Мария — 18"
  const re = /^\s*([A-Za-zА-Яа-яЁёІіЇїЙйЪъЬь\- ]{2,})\s*[-–—:]\s*([0-9]+(?:[.,][0-9]{1,2})?)/gm;
  let m;
  while((m=re.exec(txt))!==null){
    let name=m[1].trim().replace(/\s+/g,' ');
    let amount=parseFloat(String(m[2]).replace(',','.'));
    if(Number.isFinite(amount) && name) out.push({name,amount});
  }
  return out;
}
function downloadBlob(blob, filename){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=filename; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
}

/* ========= Search panel ========= */
const panel=document.getElementById('searchPanel');
document.getElementById('searchBtn').onclick=()=>{
  panel.classList.toggle('open'); populateNamesList();
};
document.getElementById('doSearch').onclick=search;
document.getElementById('q').addEventListener('keydown',e=>{ if(e.key==='Enter') search(); });

async function populateNamesList(){
  const names = (await DB.keys()).sort((a,b)=>a.localeCompare(b,'bg'));
  const dl=document.getElementById('namesList');
  dl.innerHTML = names.map(n=>`<option value="${escapeHtml(n)}">`).join('');
}
async function search(){
  const q=document.getElementById('q').value.trim().toLowerCase();
  const resEl=document.getElementById('result');
  if(!q){ resEl.textContent='Въведи име.'; return; }
  const val = await DB.get(q);
  if(val==null){ resEl.textContent='Няма такъв запис.'; return; }
  resEl.innerHTML = `<b>${escapeHtml(q)}</b> → <span class="pill">${val.toFixed(2)} лв</span>`;
}
function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

/* ========= Strike-through hook (детекция на права линия) ========= */
function maybeStrikeDelete(points){
  // груба детекция – права хоризонтална линия
  if(points.length<2) return;
  const [x1,y1]=points[0], [x2,y2]=points[points.length-1];
  const dx=x2-x1, dy=y2-y1; const len=Math.hypot(dx,dy);
  const angle=Math.abs(Math.atan2(dy,dx))*180/Math.PI;
  const straight = len > 200*dpi && (angle<12 || angle>168);
  if(!straight) return;
  // TODO: тук ще добавим OCR върху тесен изрязан регион и ще трием името от DB, ако се разпознае.
  console.log('Strike detected – ще го вържем с триене след като финализираме OCR.');
}

/* ========= Wire up ========= */
document.getElementById('saveBtn').onclick=()=>{ saveAll().catch(e=>{console.error(e); setStatus('Грешка при „Запази“');}); };

resizeCanvas(); addEventListener('resize', resizeCanvas, {passive:true});

/* Първоначално зареди списъка с имена */
populateNamesList();

/* Леко подгряване на OCR след 1.5s за да се кешира моделът */
setTimeout(()=>ensureWorker().catch(()=>{}), 1500);
</script>
</body>
</html>
